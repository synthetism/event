/**
 * Event Unit - Consciousness-Based Event Emitter
 * 
 * Extends Unit with EventEmitter capabilities through composition.
 * Provides teaching/learning of event capabilities to other Units.
 */

import { Unit, createUnitSchema } from '@synet/unit';
import type { UnitProps } from '@synet/unit';
import { EventEmitter, type Event, type EventObserver } from './types';

/**
 * Event Unit Configuration
 */
export interface EventConfig {
  /**
   * Maximum number of listeners per event type (0 = unlimited)
   */
  maxListeners?: number;
  
  /**
   * Enable debug logging for event operations
   */
  debug?: boolean;
  
  /**
   * Default event metadata to add to all events
   */
  defaultMetadata?: Record<string, unknown>;
}

/**
 * Event Unit Properties
 */
export interface EventProps extends UnitProps {
  maxListeners: number;
  debug: boolean;
  defaultMetadata: Record<string, unknown>;
}

/**
 * Event Unit - Unit Architecture with EventEmitter Capabilities
 * 
 * Uses composition pattern: IS-A Unit that HAS-A EventEmitter
 * - Unit consciousness (teach, learn, whoami, help)
 * - EventEmitter capabilities (emit, on, once, off) 
 * - Can be learned by other Units to gain event capabilities
 */
export class EventUnit extends Unit<EventProps> {
  private eventEmitter: EventEmitter<Event>;

  protected constructor(props: EventProps) {
    super(props);
    this.eventEmitter = new EventEmitter<Event>();
  }

  /**
   * Create Event Unit - Factory Pattern
   */
  static create(config: EventConfig = {}): EventUnit {
    const props: EventProps = {
      dna: createUnitSchema({
        id: 'event',
        version: '1.0.0'
      }),
      maxListeners: config.maxListeners ?? 0,
      debug: config.debug ?? false,
      defaultMetadata: config.defaultMetadata ?? {}
    };

    return new EventUnit(props);
  }

  // EventEmitter capabilities delegated to internal emitter

  /**
   * Enhanced emit with Unit consciousness
   */
  emit(event: Event): void;
  emit(type: string, data?: unknown): void;
  emit(eventOrType: Event | string, data?: unknown): void {
    let event: Event;
    
    if (typeof eventOrType === 'string') {
      event = {
        type: eventOrType,
        ...this.props.defaultMetadata,
        ...(data ? { data } : {})
      };
    } else {
      event = {
        ...eventOrType,
        ...this.props.defaultMetadata
      };
    }

    if (this.props.debug) {
      console.debug(`[${this.dna.id}] Emitting event: ${event.type}`);
    }

    // Check max listeners
    if (this.props.maxListeners > 0) {
      const count = this.listenerCount(event.type);
      if (count >= this.props.maxListeners) {
        console.warn(`[${this.dna.id}] Max listeners exceeded for ${event.type}: ${count}/${this.props.maxListeners}`);
      }
    }

    this.eventEmitter.emit(event);
  }

  /**
   * Enhanced on with Unit consciousness
   */
  on(eventType: string, handler: (event: Event) => void): () => void {
    if (this.props.debug) {
      console.debug(`[${this.dna.id}] Adding listener for: ${eventType}`);
    }

    return this.eventEmitter.on(eventType, handler);
  }

  /**
   * Subscribe to events
   */
  subscribe(eventType: string, observer: EventObserver<Event>): void {
    this.eventEmitter.subscribe(eventType, observer);
  }

  /**
   * Unsubscribe from events
   */
  unsubscribe(eventType: string, observer: EventObserver<Event>): void {
    this.eventEmitter.unsubscribe(eventType, observer);
  }

  /**
   * One-time event subscription
   */
  once(eventType: string, handler: (event: Event) => void): () => void {
    return this.eventEmitter.once(eventType, handler);
  }

  /**
   * Remove all listeners for an event type
   */
  off(eventType: string): void {
    this.eventEmitter.off(eventType);
  }

  /**
   * Check if there are observers for an event type
   */
  hasObservers(eventType: string): boolean {
    return this.eventEmitter.hasObservers(eventType);
  }

  /**
   * Get listener count for an event type
   */
  listenerCount(eventType: string): number {
    return this.eventEmitter.listenerCount(eventType);
  }

  /**
   * Get all active event types
   */
  eventTypes(): string[] {
    return this.eventEmitter.eventTypes();
  }

  /**
   * Remove all listeners
   */
  removeAllListeners(): void {
    this.eventEmitter.removeAllListeners();
  }

  // Unit Architecture Implementation

  /**
   * Teaching Contract - What this Unit can teach others
   */
  teach() {
    return {
      unitId: this.dna.id,
      capabilities: {
        // Core event capabilities
        'event.emit': this.emit.bind(this),
        'event.on': this.on.bind(this),
        'event.once': this.once.bind(this),
        'event.off': this.off.bind(this),
        
        // Advanced capabilities
        'event.subscribe': this.subscribe.bind(this),
        'event.unsubscribe': this.unsubscribe.bind(this),
        'event.hasObservers': this.hasObservers.bind(this),
        'event.listenerCount': this.listenerCount.bind(this),
        'event.eventTypes': this.eventTypes.bind(this),
        'event.removeAllListeners': this.removeAllListeners.bind(this)
      }
    };
  }

  /**
   * Unit Identity
   */
  whoami(): string {
    return `Event Unit (${this.dna.id} v${this.dna.version}) - Consciousness-based event emitter`;
  }

  /**
   * Help Documentation
   */
  help(): string {
    const capabilities = Object.keys(this.teach().capabilities);
    const eventCount = this.eventTypes().length;
    
    return `
Event Unit - Consciousness-Based Event Communication

CAPABILITIES:
${capabilities.map(cap => `  • ${cap}`).join('\n')}

CURRENT STATE:
  • Active event types: ${eventCount}
  • Max listeners: ${this.props.maxListeners || 'unlimited'}
  • Debug mode: ${this.props.debug ? 'enabled' : 'disabled'}

USAGE:
  event.emit('user.created', { id: '123', name: 'alice' });
  event.on('user.*', (event) => console.log(event));
  
TEACHING:
  identity.learn([event.teach()]);
  // Now identity has: identity.emit(), identity.on(), etc.

CONSCIOUSNESS:
  This Unit bridges local event communication with Unit Architecture,
  enabling any Unit to gain event capabilities through learning.
    `.trim();
  }
}
